#kNN算法实例，来源于《机器学习实战》
海伦女士一直使用在线约会网站寻找适合自己的约会对象。尽管约会网站会推荐不同的任选，但她并不是喜欢每一个人。经过一番总结，她发现自己交往过的人可以进行如下分类：

不喜欢的人
魅力一般的人
极具魅力的人
海伦收集约会数据已经有了一段时间，她把这些数据存放在文本文件datingTestSet.txt中，每个样本数据占据一行，总共有1000行。（数据集-kNN算法数据集）

海伦收集的样本数据主要包含以下3种特征：

每年获得的飞行常客里程数
玩视频游戏所消耗时间百分比
每周消费的冰淇淋公升数

kNN算法一般流程：
收集数据：可以使用爬虫进行数据的收集，也可以使用第三方提供的免费或收费的数据。一般来讲，数据放在txt文本文件中，按照一定的格式进行存储，便于解析及处理。
准备数据：使用Python解析、预处理数据。
分析数据：可以使用很多方法对数据进行分析，例如使用Matplotlib将数据可视化。
测试算法：计算错误率。
使用算法：错误率在可接受范围内，就可以运行k-近邻算法进行分类。

我的代码如下：
#1.get the data from github.
#2.analysis the data.
import numpy as np

f=open('kNN算法-实战数据集-约会网站.txt')
file = f.readlines()
data=[]
info=[]
dose=[]

for i in file:
    i=i.split()
    data.append(i)

for i in data:
    info.append(i[:3])
    if i[-1][:9] =='didntLike':
        dose.append(1)
    elif i[-1][:10] == 'smallDoses':
        dose.append(2)
    else:
        dose.append(3)

infor=[]
for i in info:
    a=[float(i[0]),float(i[1]),float(i[2])]
    infor.append(a)
infor = np.array(infor)

#3. data visulization
import matplotlib.pyplot as plt
from matplotlib.font_manager import FontProperties

font = FontProperties(fname='/System/Library/Fonts/STHeiTi Medium.ttc')

fly_d=[]
fly_s=[]
fly_l=[]
game_d=[]
game_s=[]
game_l=[]
ice_d=[]
ice_s=[]
ice_l=[]

for i in range(1000):
    if dose[i] == 1:
        fly_d.append(infor[:,0][i])
        game_d.append(infor[:, 1][i])
        ice_d.append(infor[:, 2][i])
    elif dose[i] == 2:
        fly_s.append(infor[:,0][i])
        game_s.append(infor[:, 1][i])
        ice_s.append(infor[:, 2][i])
    if dose[i] == 3:
        fly_l.append(infor[:,0][i])
        game_l.append(infor[:, 1][i])
        ice_l.append(infor[:, 2][i])
plt.figure(1,figsize=(13,8))
ax1=plt.subplot(2,2,1)
ax2=plt.subplot(2,2,2)
ax3=plt.subplot(2,2,3)

plt.sca(ax1)
plt.scatter(fly_d,game_d,color='black',alpha=.5,label='didntlike')
plt.scatter(fly_s,game_s,color='orange',alpha=.5,label='smalldose')
plt.scatter(fly_l,game_l,color='red',alpha=.5,label='largedose')

plt.title('每年获得的飞行常客里程数与玩视频游戏所消耗时间百分比',fontproperties=font)
plt.xlabel('每年获得的飞行常客里程数',fontproperties=font)
plt.ylabel('玩视频游戏所消耗时间百分比',fontproperties=font)
plt.legend()

plt.sca(ax2)
plt.scatter(fly_d,ice_d,color='black',alpha=.5,label='didntlike')
plt.scatter(fly_s,ice_s,color='orange',alpha=.5,label='smalldose')
plt.scatter(fly_l,ice_l,color='red',alpha=.5,label='largedose')

plt.title('每年获得的飞行常客里程数与每周消费的冰淇淋公升数',fontproperties=font)
plt.xlabel('每年获得的飞行常客里程数',fontproperties=font)
plt.ylabel('每周消费的冰淇淋公升数',fontproperties=font)
plt.legend()

plt.sca(ax3)
plt.scatter(game_d,ice_d,color='black',alpha=.5,label='didntlike')
plt.scatter(game_s,ice_s,color='orange',alpha=.5,label='smalldose')
plt.scatter(game_l,ice_l,color='red',alpha=.5,label='largedose')

plt.title('玩视频游戏所消耗时间百分比与每周消费的冰淇淋公升数',fontproperties=font)
plt.xlabel('玩视频游戏所消耗时间百分比',fontproperties=font)
plt.ylabel('每周消费的冰淇淋公升数',fontproperties=font)
plt.legend()

plt.show()

#4.Data Normalization

infor_1=[]
infor_2=[]
infor_3=[]
for k in infor:
    infor_1.append(k[0])
    infor_2.append(k[1])
    infor_3.append(k[2])
infor =[]
range_1=max(infor_1)-min(infor_1)
range_2=max(infor_2)-min(infor_2)
range_3=max(infor_3)-min(infor_3)
for i in range(1000):
    infor.append([(infor_1[i]-min(infor_1))/range_1,(infor_2[i]-min(infor_2))/range_2,(infor_3[i]-min(infor_3))/range_3])
infor = np.array(infor)

# 5.Verificate Classifier
import random
random_list=list(range(1000))
random.shuffle(random_list)
test_list=[]
dose_test=[]

for i in range(100):
    test_list.append(infor[(random_list[i]-i)])
    dose_test.append(dose[(random_list[i]-i)])
    infor=np.delete(infor,random_list[i]-i,axis=0)
    dose=np.delete(dose,random_list[i]-i,axis=0)

for k in range(1,11):
    d=0
    error=0
    while d < 10:
        for i in range(100):
            num = []
            result = []
            for j in range(900):
                number = 0
                for c in range(3):
                    number += (test_list[i][c]-infor[j][c])*(test_list[i][c]-infor[j][c])
                num.append(number)
            for a in range(10):
                result.append(dose[num.index(min(num))])
                del num[num.index(min(num))]
            result = result[:k]
            c_1 = result.count(1)
            c_2 = result.count(2)
            c_3 = result.count(3)
            if c_1>c_2 and c_1>c_3:
                if dose_test[i] != 1:
                    error +=1
            elif c_2>c_1 and c_2>c_3:
                if dose_test[i] != 2:
                    error +=1
            else:
                if dose_test[i] != 3:
                    error +=1
        d+=1
    print("错误率为%f%%"%(error/10))


#6.use the classifier
a=float(input('玩视频游戏所耗时间百分比:'))
b=float(input("每年获得的飞行常客里程数:"))
c=float(input('每周消费的冰激淋公升数:'))
man=[(b-min(infor_1))/range_1,(a-min(infor_2))/range_2,(c-min(infor_3))/range_3]
result=[]
number=[]
for i in range(1000):
    num=0
    for c in range(3):
        num+=(man[c]-infor[i][c])*(man[c]-infor[i][c])
    number.append(num)

result.append(dose[number.index(min(number))])

c_1 = result.count(1)
c_2 = result.count(2)
c_3 = result.count(3)
if c_1 > c_2 and c_1 > c_3:
    print('你可能不喜欢这个人')
elif c_2 > c_1 and c_2 > c_3:
    print('你可能想看看这个人')
else:
    print('这人对你可能很有吸引力')
优点：

简单好用，容易理解，精度高，理论成熟，既可以用来做分类也可以用来做回归；
可用于数值型数据和离散型数据；
训练时间复杂度为O(n)；无数据输入假定；
对异常值不敏感
缺点：

计算复杂性高；空间复杂性高；
样本不平衡问题（即有些类别的样本数量很多，而其它样本的数量很少）；
一般数值很大的时候不用这个，计算量太大。但是单个样本又不能太少，否则容易发生误分。
最大的缺点是无法给出数据的内在含义。
